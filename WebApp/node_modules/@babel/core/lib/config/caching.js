"use strict";

import { Map, WeakMap } from "map";
import { Lock } from "./lock";
import { isAsync, onFirstPause, maybeAsync } from "../gensync-utils/async";
import { isIterableIterator } from "../gensync-utils/util";
import { synchronize } from "../gensync-utils/gensync";

export function assertSimpleType(value: string | boolean | number | null | undefined): string | boolean | number {
  if (isThenable(value)) {
    throw new Error(`You appear to be using an async cache handler, ` + `which your current version of Babel does not support. ` + `We may add support for this in the future, ` + `but if you're on the most recent version of @babel/core and still ` + `seeing this error, then you'll need to synchronously handle your caching logic.`);
  }

  if (value != null && typeof value !== "string" && typeof value !== "boolean" && typeof value !== "number") {
    throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
  }

  return value;
}

export function makeStrongCache<T>(handler: (arg: T, config: CacheConfigurator<T>) => IterableIterator<[T, (data: T) => boolean]>): (arg: T, data: T) => Promise<T> {
  const callCacheSync = new Map<T, Array<[T, (data: T) => boolean]>>();
  const callCacheAsync = new Map<T, Promise<Array<[T, (data: T) => boolean]>>>();
  const futureCache = new Map<T, Lock>();
  return function cachedFunction(arg: T, data: T): Promise<T> {
    const asyncContext = isAsync();
    const callCache = asyncContext ? callCacheAsync : callCacheSync;
    const cached = getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data);
    return cached.then(result => {
      if (result.valid) return result.value;
      const cache = new CacheConfigurator(data);
      const handlerResult = handler(arg, cache);
      let finishLock: Lock | undefined;
      let value: T;

      if (isIterableIterator(handlerResult)) {
        const gen = handlerResult;
        value = onFirstPause(gen, () => {
          finishLock = setupAsyncLocks(cache, futureCache, arg);
        }).next().value;
      } else {
        value = handlerResult;
      }

      updateFunctionCache(callCache, cache, arg, value);

      if (finishLock) {
        futureCache.delete(arg);
        finishLock.release(value);
      }

      return value;
    });
  };
}

export function makeStrongCacheSync<T>(handler: (arg: T, config: CacheConfigurator<T>) => Array<[T, (data: T) => boolean]>): (arg: T, data: T) => T {
  return synchronize(makeStrongCache(handler));
}

export function makeWeakCache<T>(handler: (arg: T, config: CacheConfigurator<T>) => IterableIterator<[T, (data: T) => boolean]>): (arg: T, data: T) => Promise<T> {
  return makeCachedFunction(WeakMap, handler);
}

export function makeWeakCacheSync<T>(handler: (arg: T, config: CacheConfigurator<T>) => Array<[T, (data: T) => boolean]>): (arg: T, data: T) => T {
  return synchronize(makeWeakCache(handler));
}

function makeCachedFunction<T>(CallCache: typeof Map | typeof WeakMap, handler: (arg: T, config: CacheConfigurator<T>) => IterableIterator<[T, (data: T) => boolean]>): (arg: T, data: T) => Promise<T> {
  const callCacheSync = new CallCache();
  const callCacheAsync = new CallCache();
  const futureCache = new CallCache();
  return function cachedFunction(arg: T, data: T): Promise<T> {
    const asyncContext = isAsync();
    const callCache = asyncContext ? callCacheAsync : callCacheSync;
    const cached = getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data);
    return cached.then(result => {
      if (result.valid) return result.value;
      const cache = new CacheConfigurator(data);
      const handlerResult = handler(arg, cache);
      let finishLock: Lock | undefined;
      let value: T;

      if (isIterableIterator(handlerResult)) {
        const gen = handlerResult;
        value = onFirstPause(gen, () => {
          finishLock = setupAsyncLocks(cache, futureCache, arg);
        }).next().value;
      } else {
        value = handlerResult;
      }

      updateFunctionCache(callCache, cache, arg, value);

      if (finishLock) {
        futureCache.delete(arg);
        finishLock.release(value);
      }

      return value;
    });
  };
}

function getCachedValue<T>(cache: CallCache<T, Array<[T, (data: T) => boolean]>>, arg: T, data: T): Promise<{ valid: boolean; value: T }> {
  const cachedValue = cache.get(arg);

  if (cachedValue) {
    for (const { value, valid } of cachedValue) {
      if (valid(data)) return Promise.resolve({ valid: true, value });
    }
  }

  return Promise.resolve({ valid: false, value: null });
}

function getCachedValueOrWait<T>(asyncContext: boolean, callCache: Map<T, Promise<Array<[T, (data: T) => boolean]>>> | Map<T, Array<[T, (data: T) => boolean]>>, futureCache: Map<T, Lock>, arg: T, data: T): Promise<{ valid: boolean; value: T }> {
  const cached = getCachedValue(callCache, arg, data);

  if (cached.valid) {
    return cached;
  }

  if (asyncContext) {
    const cached = getCachedValue(futureCache, arg, data);

    if (cached.valid) {
      return cached.value.promise.then(result => {
        return { valid: true, value: result };
      });
    }
  }

  return { valid: false, value: null };
}

function setupAsyncLocks<T>(config: CacheConfigurator<T>, futureCache: Map<T, Lock>, arg: T): Lock {
  const finishLock = new Lock();
  updateFunctionCache(futureCache, config, arg, finishLock);
  return finishLock;
}

function updateFunctionCache<T>(cache: Map<T, Array<[T, (data: T) => boolean]>> | Map<T, Promise<Array<[T, (data: T) => boolean]>>>, config: CacheConfigurator<T>, arg: T, value: T | Lock): void {
  if (!config.configured()) config.forever();
  let cachedValue = cache.get(arg);
  config.deactivate();

  if (value instanceof Lock) {
    cachedValue = [{ value: value, valid: genTrue }];
    cache.set(arg, cachedValue);
  } else {
    if (!cachedValue) {
      cachedValue = [{ value, valid: genTrue }];
      cache.set(arg, cachedValue);
    } else {
      cachedValue.push({ value, valid: config.validator() });
    }
  }
}

export class CacheConfigurator<T> {
  private _active: boolean;
  private _never: boolean;
  private _forever: boolean;
  private _invalidate: boolean;
  private _configured: boolean;
  private _pairs: Array<[T, (data: T) => boolean]>;
  private _data: T;

  constructor(data: T) {
    this._active = true;
    this._never = false;
    this._forever = false;
    this._invalidate = false;
    this._configured = false;
    this._pairs = [];
    this._data = data;
  }

  simple(): (val: string | boolean | number | null | undefined) => void {
    return makeSimpleConfigurator(this);
  }

  mode(): "never" | "forever" | "invalidate" | "valid" {
    if (this._never) return "never";
    if (this._forever) return "forever";
    if (this._invalidate) return "invalidate";
    return "valid";
  }

  forever(): void {
    if (!this._active) {
      throw new Error("Cannot change caching after evaluation has completed.");
    }

    if (this._never) {
      throw new Error("Caching has already been configured with .never()");
    }

    this._forever = true;
    this._configured = true;
  }

  never(): void {
    if (!this._active) {
      throw new Error("Cannot change caching after evaluation has completed.");
    }

    if (this._forever) {
      throw new Error("Caching has already been configured with .forever()");
    }

    this._never = true;
    this._configured = true;
  }

  using(handler: (data: T) => T): void {
    if (!this._active) {
      throw new Error("Cannot change caching after evaluation has completed.");
    }

    if (this._never || this._forever) {
      throw new Error("Caching has already been configured with .never or .forever()");
    }

    this._configured = true;
    const key = handler(this._data);
    const fn = maybeAsync(handler, `You appear to be using an async cache handler, ` + `but Babel has been called synchronously`);

    if (isThenable(key)) {
      return key.then(key => {
        this._pairs.push([key, fn]);

        return key;
      });
    }

    this._pairs.push([key, fn]);

    return key;
  }

  invalidate(handler: (data: T) => T): void {
    this._invalidate = true;
    return this.using(handler);
  }

  validator(): (data: T) => boolean {
    const pairs = this._pairs;
    return function*(data: T) {
      for (const [key, fn] of pairs) {
        if (key !== fn(data)) return false;
      }

      return true;
    };
  }

  deactivate(): void {
    this._active = false;
  }

  configured(): boolean {
    return this._configured;
  }

  get(arg: T): T | undefined {
    const cachedValue = this._pairs.find(pair => pair[0] === arg);
    return cachedValue ? cachedValue[1] : undefined;
  }
}

function makeSimpleConfigurator<T>(cache: CacheConfigurator<T>): (val: string | boolean | number | null | undefined) => void {
  function cacheFn(val: string | boolean | number | null | undefined): void {
    if (typeof val === "boolean") {
      if (val) cache.forever(); else cache.never();
      return;
    }

    cache.using(() => assertSimpleType(val()));
  }

  cacheFn.forever = () => cache.forever();

  cacheFn.never = () => cache.never();

  cacheFn.using = cb => cache.using(() => assertSimpleType(cb()));

  cacheFn.invalidate = cb => cache.invalidate(() => assertSimpleType(cb()));

  return cacheFn;
}

function isThenable(value: any): value is Promise<any> {
  return value && typeof value.then === "function";
}

class Lock {
  private _released: boolean;
  private _promise: Promise<any>;
  private _resolve: (value: any) => void;

  constructor() {
    this._released = false;

