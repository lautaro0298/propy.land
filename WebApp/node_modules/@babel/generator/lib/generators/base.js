"use strict";

// Added @babel/polyfill as a dependency
require("@babel/polyfill");

const esprima = require("estree");
const estreePrinter = require("estree-printer");

const printer = estreePrinter({
  printIndent: function (indent) {
    return "  ".repeat(indent);
  }
});

class BlockStatement {
  constructor(node) {
    super();
    this.print = printer.print.bind(printer);
    this.token = printer.token.bind(printer);
    this.source = printer.source.bind(printer);
    this.semicolon = printer.semicolon.bind(printer);
    this.newline = printer.newline.bind(printer);
    this.rightBrace = printer.rightBrace.bind(printer);
    this.endsWith = printer.endsWith.bind(printer);
    this.getPossibleRaw = printer.getPossibleRaw.bind(printer);
    this.printInnerComments = printer.printInnerComments.bind(printer);
    this.printSequence = printer.printSequence.bind(printer);

    if (node.program) {
      this.print(node.program.interpreter, node);
    }

    this.print(node.program, node);
  }
}

exports.BlockStatement = BlockStatement;

class Directive {
  constructor(node) {
    super();
    this.print = printer.print.bind(printer);

    this.print(node.value, node);
    this.semicolon();
  }
}

exports.Directive = Directive;

class DirectiveLiteral {
  constructor(node) {
    super();
    this.print = printer.print.bind(printer);
    this.getPossibleRaw = printer.getPossibleRaw.bind(printer);

    const raw = this.getPossibleRaw(node);

    if (!this.format.minified && raw != null) {
      this.token(raw);
      return;
    }

    const {
      value
    } = node;

    if (!unescapedDoubleQuoteRE.test(value) && !unescapedSingleQuoteRE.test(value)) {
      this.token(`"${value}"`);
    } else {
      throw new Error("Malformed AST: it is not possible to print a directive containing" + " both unescaped single and double quotes.");
    }
  }
}

exports.DirectiveLiteral = DirectiveLiteral;

class File {
  constructor(node) {
    super();
    this.print = printer.print.bind(printer);

    if (node.program) {
      this.print(node.program.interpreter, node);
    }

    this.print(node.program, node);
  }
}

exports.File = File;

const unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
const unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;

class InterpreterDirective {
  constructor(node) {
    super();
    this.print = printer.print.bind(printer);

    this.token(`#!${node.value}\n`);
  }
}

exports.InterpreterDirective = InterpreterDirective;

class Program {
  constructor(node) {
    super();
    this.print = printer.print.bind(printer);
    this.printInnerComments = printer.printInnerComments.bind(printer);
    this.printSequence = printer.printSequence.bind(printer);

    this.printInnerComments(node, false);
    this.printSequence(node.directives, node);
    if (node.directives && node.directives.length) this.newline();
    this.printSequence(node.body, node);
  }
}

exports.Program = Program;

class Placeholder {
  constructor(node) {
    super();
    this.print = printer.print.bind(printer);
    this.token = printer.token.bind(printer);

    this.token("%%");
    this.print(node.name);
    this.token("%%");

    if (node.expectedNode === "Statement") {
      this.semicolon();
    }
  }
}

exports.Placeholder = Placeholder;
