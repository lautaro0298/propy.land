/* MIT license */
const colorNames = require('color-name');

const convert = {
  rgb: { channels: 3, labels: 'rgb' },
  hsl: { channels: 3, labels: 'hsl' },
  hsv: { channels: 3, labels: 'hsv' },
  hwb: { channels: 3, labels: 'hwb' },
  cmyk: { channels: 4, labels: 'cmyk' },
  xyz: { channels: 3, labels: 'xyz' },
  lab: { channels: 3, labels: 'lab' },
  lch: { channels: 3, labels: 'lch' },
  hex: { channels: 1, labels: ['hex'] },
  keyword: { channels: 1, labels: ['keyword'] },
  ansi16: { channels: 1, labels: ['ansi16'] },
  ansi256: { channels: 1, labels: ['ansi256'] },
  hcg: { channels: 3, labels: ['h', 'c', 'g'] },
  apple: { channels: 3, labels: ['r16', 'g16', 'b16'] },
  gray: { channels: 1, labels: ['gray'] }
};

// Validate and define immutable properties
Object.keys(convert).forEach(model => {
  if (!Array.isArray(convert[model].channels)) {
    throw new Error(`Invalid channels for ${model}`);
  }

  if (!Array.isArray(convert[model].labels)) {
    throw new Error(`Invalid labels for ${model}`);
  }

  if (convert[model].channels.length !== convert[model].labels.length) {
    throw new Error(`Channel and label counts mismatch for ${model}`);
  }

  const { channels, labels } = convert[model];
  Object.defineProperties(convert[model], {
    channels: { value: channels },
    labels: { value: labels }
  });
});

// Helper function to throw error for invalid input
const throwError = (model, input) => {
  if (!Array.isArray(input) || input.length !== convert[model].channels) {
    throw new Error(`Invalid input for ${model}: expected ${convert[model].channels}-element array`);
  }
};

// Helper function to validate and normalize input values
const validateInput = (model, input) => {
  throwError(model, input);
  return input.map(value => {
    if (value < 0 || value > 255) {
      throw new Error(`Invalid value for ${model}: expected value between 0 and 255`);
    }
    return value;
  });
};

// ... rest of the code
