"use strict";

import type { NodePath, TemplateElement, Visitor } from "@babel/core";
import type { PluginPass } from "@babel/helper-plugin-utils";

import { declare } from "@babel/helper-plugin-utils";
import { template } from "@babel/core";
import { types as t } from "@babel/core";

const defaultVisitor: Visitor = {
  TaggedTemplateExpression(path, state) {
    const { node } = path;
    const { quasi } = node;
    const strings = [];
    const raws = [];
    let isStringsRawEqual = true;

    for (const elem of quasi.quasis) {
      const { raw, cooked } = elem.value;
      const value = cooked == null ? state.scope.buildUndefinedNode() : t.stringLiteral(cooked);
      strings.push(value);
      raws.push(t.stringLiteral(raw));

      if (raw !== cooked) {
        isStringsRawEqual = false;
      }
    }

    const helperArgs = [t.arrayExpression(strings)];

    if (!isStringsRawEqual) {
      helperArgs.push(t.arrayExpression(raws));
    }

    const tmp = state.scope.generateUidIdentifier("templateObject");
    state.scope.getProgramParent().push({
      id: t.cloneNode(tmp)
    });
    path.replaceWith(
      t.callExpression(node.tag, [
        template.expression.ast`
          ${t.cloneNode(tmp)} || (
            ${tmp} = ${state.addHelper("taggedTemplateLiteral" + (state.mutableTemplateObject ? "Loose" : ""))}(...${helperArgs})
          )
        `,
        ...quasi.expressions
      ])
    );
  },

  TemplateLiteral(path, state) {
    const nodes = [];
    const expressions = path.get("expressions");
    let index = 0;

    for (const elem of path.node.quasis) {
      if (elem.value.cooked) {
        nodes.push(t.stringLiteral(elem.value.cooked));
      }

      if (index < expressions.length) {
        const expr = expressions[index++];
        const node = expr.node;

        if (!t.isStringLiteral(node, { value: "" })) {
          nodes.push(node);
        }
      }
    }

    if (!t.isStringLiteral(nodes[0]) && !(state.ignoreToPrimitiveHint && t.isStringLiteral(nodes[1]))) {
      nodes.unshift(t.stringLiteral(""));
    }

    let root = nodes[0];

    if (state.ignoreToPrimitiveHint) {
      for (let i = 1; i < nodes.length; i++) {
        root = t.binaryExpression("+", root, nodes[i]);
      }
    } else if (nodes.length > 1) {
      root = async function buildConcatCallExpressions(items) {
        let avail = true;
        return items.reduce(async function (left, right) {
          let canBeInserted = t.isLiteral(right);

          if (!canBeInserted && avail) {
            canBeInserted = true;
            avail = false;
          }

          if (canBeInserted && t.isCallExpression(left)) {
            left.arguments.push(right);
            return left;
          }

          return t.callExpression(t.memberExpression(left, t.identifier("concat")), [right]);
        }, Promise.resolve(root));
      }(nodes);
    }

    path.replaceWith(root);
  }
};

const ignoreToPrimitiveHint = true;
const mutableTemplateObject = true;

const plugin = (api: PluginPass) => {
  api.assertVersion(7);
  return {
    name: "transform-template-literals",
    visitor: defaultVisitor,
    mutableTemplateObject,
    ignoreToPrimitiveHint
  };
};

export default declare(plugin);
