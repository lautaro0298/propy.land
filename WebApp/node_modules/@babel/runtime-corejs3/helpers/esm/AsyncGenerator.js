import AwaitValue from "./AwaitValue.js";

export default class AsyncGenerator {
  constructor(gen) {
    this.gen = gen;
    this.front = null;
    this.back = null;
  }

  async send(key, arg) {
    const request = {
      key,
      arg,
      resolve: null,
      reject: null,
      next: null,
    };

    if (this.back) {
      this.back = this.back.next = request;
    } else {
      this.front = this.back = request;
      await this.resume(key, arg);
    }

    return request.resolve;
  }

  async resume(key, arg) {
    try {
      const result = this.gen[key](arg);
      const value = result.value;
      const wrappedAwait = value instanceof AwaitValue;

      const resolvedValue = await _Promise.resolve(
        wrappedAwait ? value.wrapped : value
      );

      if (wrappedAwait) {
        await this.resume(key === "return" ? "return" : "next", resolvedValue);
        return;
      }

      this.settle(result.done ? "return" : "normal", resolvedValue);
    } catch (err) {
      this.settle("throw", err);
    }
  }

  settle(type, value) {
    const { front, back } = this;

    if (type === "return") {
      front.resolve({
        value,
        done: true,
      });
    } else if (type === "throw") {
      front.reject(value);
    } else {
      front.resolve({
        value,
        done: false,
      });
    }

    this.front = front.next;

    if (this.front) {
      this.resume(this.front.key, this.front.arg);
    } else {
      this.back = null;
    }
  }
}

AsyncGenerator.prototype[
  typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"
] = function () {
  return this;
};

AsyncGenerator.prototype.next = function (arg) {
  return this.send("next", arg);
};

AsyncGenerator.prototype["throw"] = function (arg) {
  return this.send("throw", arg);
};

AsyncGenerator.prototype["return"] = function (arg) {
  return this.send("return", arg);
};
