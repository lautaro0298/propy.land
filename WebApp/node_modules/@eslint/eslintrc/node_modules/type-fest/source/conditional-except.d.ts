import { Except } from './except';

/**
 * Check if a type is a primitive type
 * @example
 * type A = IsPrimitive<string>; // true
 * type B = IsPrimitive<number>; // true
 * type C = IsPrimitive<boolean>; // true
 * type D = IsPrimitive<() => void>; // false
 * type E = IsPrimitive<{}>; // false
 */
type IsPrimitive<T> = T extends Function
  ? false
  : T extends object
  ? never
  : T extends (infer U)[]
  ? IsPrimitive<U>
  : true;

/**
 * Get the keys of an object that match the given condition
 * @example
 * type A = ConditionalKeys<{ a: string; b: number; c: () => void }, IsPrimitive>; // "a" | "b"
 */
type ConditionalKeys<T, Condition> = {
  [K in keyof T]: Condition extends IsPrimitive<T[K]> ? K : never;
}[keyof T];

/**
 * Exclude keys from a shape that matches the given `Condition`.
 * @example
 * import { Primitive, ConditionalExcept } from 'type-fest';
 *
 * class Awesome {
 *   name: string;
 *   successes: number;
 *   failures: bigint;
 *
 *   run() {}
 * }
 *
 * type ExceptPrimitivesFromAwesome = ConditionalExcept<Awesome, Primitive>;
 * //=> {run: () => void}
 */
export type ConditionalExcept<Base, Condition> = Except<
  Base,
  {
    [K in ConditionalKeys<Base, Condition>]: Base[K];
  }
>;
